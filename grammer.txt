# Ink Grammer
//Assume all white spaces are ignored, except for newlines
//TODO: Define when newlines are ignored
## Knots & Stiches
root:				includes* variable_definition* knot_body? Knot*

knot:				knot_signature knot_body
knot_body:			stitch*

stitch:				stitch_signature  stitch_body
stitch_body:		weave* 

function:			function_signature Function_body
function_body:		X_content_block*

knot_signature:		'==' [=]*            identifier parameter_list? [=]*
function_signature:	'==' [=]* 'function' identifier parameter_list? [=]*
stitch_signature:	'='                  identifier parameter_list?      
parameter_list:		( '(' (param [',' param ]*)? ')' )
param:				'ref'? '->'? identifer

## Weaves
weave:				X_content_block* ( (choice | conditional_choice_block) weave?)* gather? //Note: Give warning on multiple fallback choices?

choice:				('*' | '+')+ label? choice_condition* X_content_block* ( '[' X_content_block* ']' X_content_block* )?

conditional_choice_block: '{' expression     ':' ( choice branch )* ('-' 'else' ':' ( choice branch )* '}'

choice_condition:	'{' expression '}'

gather:				('-')+ label?
//NOTE: '-'s can be seperated by space or tab, or not seperated at all

label:				'(' identifier ')'

## Content
content:			text | branch |                    '{' ( eval | (logic | return) |       alternative | (                      conditional ) ) '}'
content_block:	 	      content |				       '{' (						   alternative_block | ( conditional_block | switch_block ) ) '}'
X_content:			      content | (logic | return) 
X_content_block:	                       X_content | '{' (						   alternative_block | ( conditional_block | switch_block ) ) '}'

text:	String | alternativve | conditional 
eval:	expression

alternative:		(alternate_type_sym)?   content* ( '|'         content* )* 
alternative_block:	(alternate_type ':')  (            '-' X_content_block* )* 

alternate_type_sym:	                '!' |     '&' |       '~'
alternate_type:		'stopping' | 'once' | 'cycle' | 'shuffle' |'shuffle once' | 'shuffle stopping' 

conditional:		(expression ':') ( (				  )   content_block* )  ( (           '|')   content_block* )?
condition_list:		                 ( ('-' expression ':') X_content_block* )* ( ('-' 'else' ':') X_content_block* )?

conditional_block:	(			      				   ) condition_list
switch_block:		( expression ':' conditional_block )


## Branching
branch:				divert | tunnel | tunnel_return | thread
divert:				'->' ((identifier | variable) | 'DONE' | 'END')
tunnel:				divert+ (divert | '->')
tunnel_return:		'->->' (identifier | variable | 'DONE' | 'END')?
thread:				'<-' ((identifier | variable) | 'DONE' | 'END')

//Note: while return branches it can only be used in functions, thus it's not treated as a divert
return:				'~' 'return' (expression | function_call )

 
## Variables & Lists
Variable_definition:		'VAR' identifier '=' ( ink_value | constant)
Temp_Variable_definition:	'temp' identifier '=' (ink_value | variable | constant)
Constant_definition:		'CONST' identifier '=' (Integer | Decimal | sring | constant)

List_definition:	'LIST' identifier '='  ( identifier | '(' identifier ')' | '(' identifier '=' integer ')' )  (',' ( identifier | '(' identifier ')' | '(' identifier '=' integer ')' ) )*


## Logic
logic:				'~' (expression | function_call | variable_assignment | temp_variable_definition)

variable_assignment:	identifier '=' (ink_value | variable | constant | literal)
expression:				literal | variable | constant | '(' expression ')' | (unary_op expression) | (expression bin_op expression)

//Note: Integer and Decimal allow leading and following zeros!
literal:			Integer | Decimal | '"' string '"' | ('true' | 'false') | divert | list_value
math_bin_op:		'+' | '-' | '*' | '/' | ('%' | 'mod)
string_bin_op:		'==' | '!=' | '?'
logic_bin_op:		('and' | '&&') | ('or' | '||')
bin_op:				math_bin_op | string_bin_op

math_unary_op:		'-'
logic_unary_op:		('not' | '!')
unary_op:			math_unary_op | logic_unary_op
